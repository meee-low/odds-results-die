"""
def core_flow():
    pass
    #ask for set of dice (in the format 2d6+1d4+3d10 etc.)
    #put that string through the interpreter function
    #build table based on the output of interpreter
    #ask for the result user wants
    #checks if result is possible
    #compute
    #display

"""
    
"""
def m(): #example of flow
    d = input('dice set:  ')
    tbl = build_table(dice_interpreter(d))
    r = input('result:  ')
    print(odds_of_result(tbl, r))
"""

def dice_interpreter(inp):
    #interprets the set of dice 
    #string -> list of tuples
    #examples of valid inputs: 2d10, 6d4+8d2, 1d6
    #could be bypassed if we get number of dice and faces separately
    
    #format check
    assert inp.count('d') >= 1 and inp.count('d') > inp.count('+')
    assert inp[0] not in 'd+' and inp[-1] not in 'd+'
    
    result = [] #this is what gets returned. where tuples are stored
    dice, face = '', '' #future elements of the tuple
    current_str = ''

    for i in inp:
        if i == 'd': #change from # of dice to # of faces
            assert current_str != ''
            dice = int(current_str)
            current_str = ''
        elif i == '+': #go to next set
            assert current_str != ''
            face = int(current_str)
            current_str = ''
            result.append([dice, face])
            dice, face = '', ''          
        elif i in '0123456789':
            current_str += i
        else: #not acceptable
            #print('Invalid input. Please try again')
            assert False
    face = int(current_str) #finalises the loop
    result.append([dice, face])
    
    return result

def build_table(dice):
    #each index corresponds to a result.
    #number at index is how many ways to get that result.
    #could be use to build a nice graph

    def mult(p1, p2):
        #essentially polynomial multiplication
        #p1 and p2 are lists of integers (coefficients of polynomials)
        size_p1, size_p2 = len(p1), len(p2)
        p3 = [0] * (size_p1+size_p2-1)
    
        for i in range(size_p1):
            for j in range(size_p2):
                p3[i+j] += p1[i] * p2[j]
        
        return p3

    set_odds_all = []
    
    for set_of_dice in dice: #builds a small table for each set
        assert len(set_of_dice) == 2
        one_roll = [0]+[1] * set_of_dice[1]
        set_odds = one_roll
        count = 1
        while count < set_of_dice[0]:
            set_odds = mult(set_odds, one_roll)
            count += 1
        set_odds_all.append(set_odds)

    while True: #merges tables together
        if len(set_odds_all) >= 2:
            set_odds_all = [mult(set_odds_all[0], set_odds_all[1])] + set_odds_all[2:]
        if len(set_odds_all) == 1:
            set_odds_all = set_odds_all[0]
            return set_odds_all

def odds_of_result(table, result):
    #gives odds of result as a percentage of all possible rolls
    #table is generated by build_table
    #result is user input

    int_result = int(result)
    if 0 > int_result > len(table):
        assert False #error, result not possible
    total = sum(table)
    return round(float(table[int_result])*100 / total, 3)

